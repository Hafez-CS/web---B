<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>Ø±Ø³Ù… Ù†Ù…ÙˆØ¯Ø§Ø± Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø§Ø² ÙØ§ÛŒÙ„ JSON</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
  <style>
    body{font-family: system-ui, sans-serif; margin:16px;}
    .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    #chartWrap{max-width:1200px;}
    label{white-space:nowrap;}
  </style>
</head>
<body>
  <h2>Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ - Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ù…Ø­Ù„ÛŒ</h2>

  <div class="row">
    <label>Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„ JSON Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ:</label>
    <input type="file" id="fileInput" accept="application/json" />
  </div>

  <div id="chartWrap">
    <canvas id="chart" height="120"></canvas>
  </div>

  <p id="stats" style="margin-top:8px; font-weight:600;">Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ÙØ§ÛŒÙ„ JSON Ø±Ø§ Ø¬Ù‡Øª Ø±Ø³Ù… Ù†Ù…ÙˆØ¯Ø§Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>

  <script>
    const ctx = document.getElementById('chart').getContext('2d');
    let chart;

    // --- ØªØ§Ø¨Ø¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¹ÛŒØ§Ø±Ù‡Ø§ÛŒ Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ (MAE Ùˆ RMSE) ---
    function computeMetrics(actual, predicted) {
      const n = Math.min(actual.length, predicted.length);
      let absSum = 0, sqSum = 0, count = 0;
      for (let i = 0; i < n; i++) {
        const a = Number(actual[i]), p = Number(predicted[i]);
        if (Number.isFinite(a) && Number.isFinite(p)) {
          const diff = a - p;
          absSum += Math.abs(diff);
          sqSum  += diff * diff;
          count++;
        }
      }
      const mae = count ? absSum / count : NaN;
      const rmse = count ? Math.sqrt(sqSum / count) : NaN;
      return { mae, rmse, n: count };
    }

    // --- ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø±Ø³Ù… Ù†Ù…ÙˆØ¯Ø§Ø± ---
    function drawChart(cfg) {
      // Ø³Ø§Ø®ØªØ§Ø± Ù…ÙˆØ±Ø¯ Ø§Ù†ØªØ¸Ø§Ø±: { actual_values: [...], predicted_values: [...], future_predictions: [...] }
      const actual = cfg.actual_values || [];
      const predicted = cfg.predicted_values || [];
      const future = cfg.future_predictions || [];

      if (actual.length === 0) {
        document.getElementById('stats').textContent = 'Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ "actual_values" Ø¯Ø± ÙØ§ÛŒÙ„ JSON ÛŒØ§ÙØª Ù†Ø´Ø¯.';
        if (chart) chart.destroy();
        return;
      }
      
      const historicalLength = predicted.length; // Ø·ÙˆÙ„ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø´Ø¯Ù‡ ØªØ§Ø±ÛŒØ®ÛŒ
      const totalLength = historicalLength + future.length;
      const labels = Array.from({length: totalLength}, (_, i) => i);

      // Ù…Ù†Ø·Ù‚ Ø®Ø· Ø³Ø¨Ø² Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø¢ÛŒÙ†Ø¯Ù‡: Ø¨Ø§ Null Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒØ´ÙˆØ¯ ØªØ§ Ø®Ø·ÛŒ Ù¾ÛŒÙˆØ³ØªÙ‡ Ù†Ø¨Ø§Ø´Ø¯.
      const futureDataWithNulls = new Array(historicalLength - 1).fill(null).concat([
        predicted[historicalLength - 1], // Ø¢Ø®Ø±ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ (Ù†Ù‚Ø·Ù‡ Ø§ØªØµØ§Ù„)
        ...future                      // Ù…Ù‚Ø§Ø¯ÛŒØ± Ø¢ÛŒÙ†Ø¯Ù‡
      ]);

      const ds = [
        { 
          label: 'Ù…Ù‚Ø§Ø¯ÛŒØ± ÙˆØ§Ù‚Ø¹ÛŒ (Actual)',     
          data: actual,    
          borderColor: '#1f77b4', 
          borderWidth: 2, 
          pointRadius: 0 // Ø®Ø· Ø¢Ø¨ÛŒ
        },
        { 
          label: 'Ù…Ù‚Ø§Ø¯ÛŒØ± Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒâ€ŒØ´Ø¯Ù‡ (Predicted)', 
          data: predicted, 
          borderColor: '#ff7f0e', 
          borderWidth: 2, 
          pointRadius: 0 // Ø®Ø· Ù†Ø§Ø±Ù†Ø¬ÛŒ
        },
        { 
          label: 'Ù¾ÛŒØ´â€ŒØ¨ÛŒÙ†ÛŒ Ø¢ÛŒÙ†Ø¯Ù‡ (Future)',     
          data: futureDataWithNulls,    
          borderColor: '#2ca02c', // Ø±Ù†Ú¯ Ø³Ø¨Ø²
          borderDash: [6, 6],    // Ø®Ø· Ú†ÛŒÙ†
          
          // ğŸ’¥ ØªØºÛŒÛŒØ±Ø§Øª Ø¨Ø±Ø§ÛŒ Ú©ÙˆÚ†Ú© Ø´Ø¯Ù† Ø®Ø· Ø³Ø¨Ø²
          borderWidth: 2,        // Ø¶Ø®Ø§Ù…Øª Ù†Ø±Ù…Ø§Ù„
          pointRadius: (context) => {
            // Ù†Ù‚Ø·Ù‡ Ø±Ø§ ÙÙ‚Ø· Ø¯Ø± Ø§ÙˆÙ„ÛŒÙ† Ù†Ù‚Ø·Ù‡ (Ù†Ù‚Ø·Ù‡ Ø§ØªØµØ§Ù„) Ø¨Ø²Ø±Ú¯ØªØ± Ø±Ø³Ù… Ú©Ù†
            const index = context.dataIndex;
            return index === historicalLength - 1 ? 3 : 0; 
          },        
          pointBackgroundColor: '#2ca02c'
        }
      ];

      const { mae, rmse, n } = computeMetrics(actual.slice(0, predicted.length), predicted);
      const title = `Actual vs Predicted (n=${n}) â€” MAE=${mae?.toFixed(3)}  RMSE=${rmse?.toFixed(3)}`;
      document.getElementById('stats').textContent =
        `MAE = ${mae?.toFixed(4)} , RMSE = ${rmse?.toFixed(4)} (Ø±ÙˆÛŒ ${n} Ù†Ù‚Ø·Ù‡Ù” Ù…Ø¹ØªØ¨Ø±)`;

      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: ds },
        options: {
          responsive: true,
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { position: 'top' },
            title: { display: true, text: title }
          },
          scales: {
            x: { title: { display: true, text: 'Ø§Ù†Ø¯ÛŒØ³ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§' } },
            y: { title: { display: true, text: 'Ù…Ù‚Ø¯Ø§Ø±' }, ticks: { beginAtZero: false } }
          },
          elements: { line: { tension: 0 } } // Ø¨Ø¯ÙˆÙ† Ø®Ù…ÛŒØ¯Ú¯ÛŒ
        }
      });
    }

    // --- Ù…Ù†Ø·Ù‚ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙØ§ÛŒÙ„ ---
    function loadFromFile(file) {
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const json = JSON.parse(e.target.result);
          drawChart(json);
        } catch (err) {
          alert('ÙØ±Ù…Øª JSON Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.');
          document.getElementById('stats').textContent = 'Ø®Ø·Ø§: ÙØ±Ù…Øª JSON Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª.';
        }
      };
      reader.readAsText(file, 'utf-8');
    }

    // --- Ø±ÙˆÛŒØ¯Ø§Ø¯ (Event) Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„ ---
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (f) loadFromFile(f);
    });
  </script>
</body>
</html>